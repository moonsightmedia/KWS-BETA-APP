<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Beta Dashboard - Kletterwelt Sauerland</title>
    <meta name="description" content="Aktuelle Boulder-√úbersicht der Kletterwelt Sauerland mit Beta-Videos, Schwierigkeitsgraden und Statistiken" />
    <meta name="author" content="Kletterwelt Sauerland" />

    <meta property="og:title" content="Beta Dashboard - Kletterwelt Sauerland" />
    <meta property="og:description" content="Entdecke alle aktuellen Boulder mit Beta-Videos und detaillierten Informationen" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://lovable.dev/opengraph-image-p98pqg.png" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@lovable_dev" />
    <meta name="twitter:image" content="https://lovable.dev/opengraph-image-p98pqg.png" />

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&family=Teko:wght@400;500;600;700&display=swap" rel="stylesheet" />
    
    <!-- Google Material Icons -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&display=swap" />

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="/080616_Kletterwelt-Sauerland_Logo_ohne_Hintergrund_ohne_Schrift.png" />
    <link rel="apple-touch-icon" href="/080616_Kletterwelt-Sauerland_Logo_ohne_Hintergrund_ohne_Schrift.png" />
    <meta name="theme-color" content="#36B531" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="apple-mobile-web-app-title" content="KWS Beta" />
    <meta name="mobile-web-app-capable" content="yes" />
    <link rel="manifest" href="/manifest.webmanifest" />
    <link rel="apple-touch-icon" href="/080616_Kletterwelt-Sauerland_Logo_ohne_Hintergrund_ohne_Schrift.png" />
  </head>

  <body>
    <div id="root"></div>
    <!-- Global error handler - must be loaded before any other scripts -->
    <script>
      (function() {
        'use strict';
        
        // Catch ALL unhandled promise rejections
        window.addEventListener('unhandledrejection', function(event) {
          var error = event.reason;
          var errorMessage = '';
          
          try {
            if (error) {
              if (typeof error === 'string') {
                errorMessage = error;
              } else if (error.message) {
                errorMessage = error.message;
              } else if (error.toString && typeof error.toString === 'function') {
                errorMessage = error.toString();
              } else {
                errorMessage = String(error);
              }
            }
            
            errorMessage = errorMessage.toLowerCase();
            
            // Ignore storage-related errors - these are expected in some contexts
            if (
              errorMessage.indexOf('storage') !== -1 ||
              errorMessage.indexOf('access to storage') !== -1 ||
              errorMessage.indexOf('not allowed from this context') !== -1 ||
              errorMessage.indexOf('access to') !== -1 && errorMessage.indexOf('context') !== -1
            ) {
              // Prevent the error from being logged to console
              event.preventDefault();
              event.stopPropagation();
              event.stopImmediatePropagation();
              // Also suppress console.error for this error
              if (console && console.error) {
                var originalError = console.error;
                console.error = function() {
                  var args = Array.prototype.slice.call(arguments);
                  var msg = args.join(' ').toLowerCase();
                  if (msg.indexOf('storage') === -1 && msg.indexOf('access to') === -1) {
                    originalError.apply(console, args);
                  }
                };
                setTimeout(function() {
                  console.error = originalError;
                }, 0);
              }
              return false;
            }
          } catch (e) {
            // Ignore errors in error handler
          }
        }, true); // Use capture phase
        
        // Also catch regular errors
        window.addEventListener('error', function(event) {
          var error = event.error;
          var errorMessage = '';
          
          try {
            if (error && error.message) {
              errorMessage = error.message.toLowerCase();
            } else if (event.message) {
              errorMessage = event.message.toLowerCase();
            }
            
            // Ignore storage-related errors
            if (
              errorMessage.indexOf('storage') !== -1 ||
              errorMessage.indexOf('access to storage') !== -1 ||
              errorMessage.indexOf('not allowed from this context') !== -1
            ) {
              event.preventDefault();
              event.stopPropagation();
              return false;
            }
          } catch (e) {
            // Ignore errors in error handler
          }
        }, true); // Use capture phase
      })();
    </script>
    <!-- CRITICAL: Override fetch BEFORE any module imports to ensure Supabase requests are intercepted -->
    <script>
      (function() {
        'use strict';
        console.log('[Index HTML] üîß Overriding fetch BEFORE module imports...');
        
        const originalFetch = window.fetch;
        let fetchCallCount = 0;
        
        window.fetch = async function(input, init) {
          // CRITICAL: Log EVERY fetch call to see what's happening
          // This MUST be the first thing to see if fetch is called at all
          const urlString = typeof input === 'string' ? input : input instanceof URL ? input.href : (input instanceof Request ? input.url : String(input));
          
          const hostname = window.location.hostname;
          console.log('[Index HTML Fetch Override] üìûüìûüìû FETCH CALLED:', {
            url: urlString,
            hostname: hostname,
            isLocalhost: hostname === 'localhost' || hostname === '127.0.0.1',
            inputType: typeof input,
            isString: typeof input === 'string',
            isURL: input instanceof URL,
            isRequest: input instanceof Request,
            method: init?.method || 'GET',
            stackTrace: new Error().stack?.substring(0, 500), // Show where fetch is called from
          });
          
          try {
            const urlObj = new URL(urlString, window.location.origin);
            console.log('[Index HTML Fetch Override] üîç Parsed URL object:', {
              hostname: urlObj.hostname,
              href: urlObj.href,
            });
            
            // Only intercept Supabase requests
            const isSupabaseRequest = urlObj.hostname.includes('supabase.co') || 
                                      urlObj.hostname.includes('supabase.io') ||
                                      urlObj.hostname.includes('.supabase.co') ||
                                      urlObj.hostname.includes('.supabase.io');
            
            console.log('[Index HTML Fetch Override] üîç Is Supabase request?', isSupabaseRequest, 'hostname:', urlObj.hostname);
            
            if (isSupabaseRequest) {
              fetchCallCount++;
              const callId = fetchCallCount;
              const startTime = Date.now();
              
              // Preserve all headers
              let headers = init?.headers;
              if (headers instanceof Headers) {
                const headersObj = {};
                headers.forEach(function(value, key) {
                  headersObj[key] = value;
                });
                headers = headersObj;
              }
              
              if (Array.isArray(headers)) {
                const headersObj = {};
                headers.forEach(function(entry) {
                  headersObj[entry[0]] = entry[1];
                });
                headers = headersObj;
              }
              
              const finalHeaders = Object.assign({}, headers || {}, init?.headers && typeof init.headers === 'object' && !(init.headers instanceof Headers) && !Array.isArray(init.headers) ? init.headers : {});
              
              if (input instanceof Request) {
                input.headers.forEach(function(value, key) {
                  if (!finalHeaders[key]) {
                    finalHeaders[key] = value;
                  }
                });
              }
              
              // CRITICAL: Log EVERYTHING to debug why requests aren't being intercepted
              console.log('[Index HTML Fetch Override] üöÄ [' + callId + '] Starting Supabase request:', {
                url: urlObj.href,
                pathname: urlObj.pathname,
                method: init?.method || 'GET',
                hasAuth: !!(finalHeaders['Authorization'] || finalHeaders['authorization']),
                hasApiKey: !!(finalHeaders['apikey'] || finalHeaders['apiKey'] || finalHeaders['x-api-key']),
                headerKeys: Object.keys(finalHeaders),
                allHeaders: finalHeaders, // Log ALL headers to see what's being sent
                timestamp: new Date().toISOString(),
              });
              
              // CRITICAL: Also log the actual fetch call
              console.log('[Index HTML Fetch Override] üìû About to call originalFetch with:', {
                url: urlObj.href,
                method: init?.method || 'GET',
                headers: finalHeaders,
              });
              
              try {
                const requestInit = Object.assign({}, init || {}, {
                  headers: finalHeaders,
                  cache: 'no-store'
                });
                
                const request = input instanceof Request 
                  ? new Request(input, requestInit)
                  : new Request(input, requestInit);
                
                const response = await originalFetch(request);
                
                const duration = Date.now() - startTime;
                console.log('[Index HTML Fetch Override] ‚úÖ [' + callId + '] Response received:', {
                  url: urlObj.href,
                  status: response.status,
                  statusText: response.statusText,
                  duration: duration + 'ms',
                });
                
                return response;
              } catch (error) {
                const duration = Date.now() - startTime;
                console.error('[Index HTML Fetch Override] ‚ùå [' + callId + '] Request failed:', {
                  url: urlObj.href,
                  error: error?.message || error,
                  duration: duration + 'ms',
                });
                throw error;
              }
            }
            
            // For non-Supabase requests, use original fetch
            return originalFetch(input, init);
          } catch (error) {
            // Fallback to original fetch if URL parsing fails
            return originalFetch(input, init);
          }
        };
        
        console.log('[Index HTML] ‚úÖ Fetch overridden successfully BEFORE module imports');
        console.log('[Index HTML] üîç Fetch override check:', {
          originalFetch: typeof originalFetch,
          windowFetch: typeof window.fetch,
          isOverridden: window.fetch !== originalFetch,
          fetchToString: window.fetch.toString().substring(0, 100),
        });
        
        // CRITICAL: Also override XMLHttpRequest in case Supabase uses it
        const originalXHR = window.XMLHttpRequest;
        const XHROverride = function() {
          const xhr = new originalXHR();
          const originalOpen = xhr.open;
          const originalSend = xhr.send;
          
          xhr.open = function(method, url, async, user, password) {
            console.log('[Index HTML XHR Override] üìû XHR.open called:', {
              method: method,
              url: url,
              isSupabase: url && (url.includes('supabase.co') || url.includes('supabase.io')),
            });
            
            if (url && (url.includes('supabase.co') || url.includes('supabase.io'))) {
              console.log('[Index HTML XHR Override] üöÄ Supabase XHR request detected:', url);
            }
            
            return originalOpen.apply(this, arguments);
          };
          
          xhr.send = function(data) {
            console.log('[Index HTML XHR Override] üì§ XHR.send called:', {
              url: this._url || 'unknown',
              method: this._method || 'unknown',
            });
            
            return originalSend.apply(this, arguments);
          };
          
          return xhr;
        };
        
        // Copy prototype
        XHROverride.prototype = originalXHR.prototype;
        // Copy static properties
        Object.setPrototypeOf(XHROverride, originalXHR);
        
        window.XMLHttpRequest = XHROverride;
        console.log('[Index HTML] ‚úÖ XMLHttpRequest also overridden');
      })();
    </script>
    <script type="module" src="/src/main.tsx?v=3"></script>
  </body>
</html>
